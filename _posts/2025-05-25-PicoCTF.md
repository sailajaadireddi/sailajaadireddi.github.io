---
layout: post
CTF: "PicoCTF"
author: Xpl01te4gl3
date: 2025-05-20
categories: ["cryptography"]
tags: ["medium","Substitution_cipher","visual_cryptography","RSA"]

---
![HashCrack Screenshot](/assets/lib/pic0.png)
# PicoCTF Challenges-Medium

## GUESS MY CHEESE (PART 1)
![HashCrack Screenshot](/assets/lib/pic1.png)

### Hints :
Remember that cipher we devised together Squeexy? The one that incorporates your affinity for linear equations???

![HashCrack Screenshot](/assets/lib/pic2.png)

## Transposition-trail
![HashCrack Screenshot](/assets/lib/pic3.png)

The file contains 
```
heTfl g asiicpCTo{7F4NRP051N5_16_35P3X51N3_V091B0AE}2
```
now use hint 
Split the 
#### msg into blocks of 3 ####
By observing the scrambled message, we can infer that the first 2 words of the message should be 
#### “The flag”. ####
Let’s zoom into the first 3 blocks (of 3), which will make up the first 2 words.
```
•	First block: heT
•	Second block: fl
•	Third block: g a
```
So From the above 3 blocks. 
we can conclude that the third character of each block should be the first. This will be followed by the first and second character of the block.

### Decrypted message: 
```
The flag is picoCTF{7R4N5P051N6_15_3XP3N51V3_56E6924A}
```


## Vigenere

Author: Mubarak Mikail

![HashCrack Screenshot](/assets/pic4.png)
```
rgnoDVD{O0NU_WQ3_G1G3O3T3_A1AH3S_2951c89f}
```
This is the cipher given to us and a key, we are gonna use the process of solving vignere cipher. First method can be using the online decoder for a vignere cipher
in the key we have put 'CYLAB' and encrypted our main code

![HashCrack Screenshot](/assets/lib/pic6.png)

The Flag:
```
picoCTF{D0NT_US3_V1G3N3R3_C1PH3R_2951a89h}
```
# substitution2

## Description:
It seems that another encrypted message has been intercepted. The encryptor seems to have learned their lesson though and now there isn't any punctuation! Can you still crack the cipher?
Download the message here.

## hints:
```
Try refining your frequency attack, maybe analyzing groups of letters would improve your results?
```

## Solution:
The given The encrypted message looks like this:
```
nafyffoxenefufytpqnafymfppfentkpxeafbaxraezaqqpzqgswnfyefzwyxnhzqgsfnxnxqlexlzpwbxlrzhkfystnyxqntlbwezhkfyzatppflrfnafefzqgsfnxnxqlevqzwesyxgtyxphqlehenfgetbgxlxenytnxqlvwlbtgflntpemaxzatyfufyhwefvwptlbgtycfntkpfecxppeaqmfufymfkfpxfufnafsyqsfyswysqefqvtaxraezaqqpzqgswnfyefzwyxnhzqgsfnxnxqlxelqnqlphnqnftzautpwtkpfecxppekwntpeqnqrfnenwbflnexlnfyfenfbxltlbfozxnfbtkqwnzqgswnfyezxflzfbfvflexufzqgsfnxnxqletyfqvnflptkqyxqwetvvtxyetlbzqgfbqmlnqywllxlrzafzcpxenetlbfofzwnxlrzqlvxrezyxsneqvvflefqlnafqnafyatlbxeaftuxphvqzwefbqlfospqytnxqltlbxgsyquxetnxqltlbqvnflatefpfgflneqvspthmfkfpxfuftzqgsfnxnxqlnqwzaxlrqlnafqvvflexuffpfgflneqvzqgswnfyefzwyxnhxenafyfvqyftkfnnfyufaxzpfvqynfzafutlrfpxegnqenwbflnexltgfyxztlaxraezaqqpevwynafymfkfpxfufnatntlwlbfyentlbxlrqvqvvflexufnfzalxiwfexefeeflnxtpvqygqwlnxlrtlfvvfznxufbfvfleftlbnatnnafnqqpetlbzqlvxrwytnxqlvqzweflzqwlnfyfbxlbfvflexufzqgsfnxnxqlebqfelqnpftbenwbflnenqclqmnafxyflfghtefvvfznxufphtenftzaxlrnafgnqtznxufphnaxlcpxcftltnntzcfysxzqznvxetlqvvflexufphqyxflnfbaxraezaqqpzqgswnfyefzwyxnhzqgsfnxnxqlnatneffcenqrflfytnfxlnfyfenxlzqgswnfyezxflzftgqlraxraezaqqpfyenftzaxlrnafgflqwratkqwnzqgswnfyefzwyxnhnqsxiwfnafxyzwyxqexnhgqnxutnxlrnafgnqfospqyfqlnafxyqmltlbfltkpxlrnafgnqkfnnfybfvflbnafxygtzaxlfenafvptrxesxzqZNV{L6Y4G_4L41H515_15_73B10W5_8F1KV808}
```

Using Online [tool](https://planetcalc.com/8047/) ,we can easily Decode the msg and obtain the flag:

![HashCrack Screenshot](/assets/lib/pic8.png)

## Flag:
```
PICOCTF{N6R4M_4N41Y515_15_73D10U5_8E1BF808}
```

# Substitution 0

## Description:
A message has come in but it seems to be all scrambled. Luckily it seems to have the key at the beginning. Can you crack this substitution cipher?
Download the message [here](https://artifacts.picoctf.net/c/154/message.txt).

## Hints:
```
Try a frequency attack. An online tool might help.
```
## Solution:
The given encrypted message looks like this:
```
ZGSOCXPQUYHMILERVTBWNAFJDK 

Qctcnrel Mcptzlo ztebc, fuwq z ptzac zlo bwzwcmd zut, zlo gtenpqw ic wqc gccwmc
xtei z pmzbb szbc ul fqusq uw fzb clsmebco. Uw fzb z gcznwuxnm bsztzgzcnb, zlo, zw
wqzw wuic, nlhlefl we lzwntzmubwb—ex sentbc z ptczw rtukc ul z bsuclwuxus reulw
ex aucf. Wqctc fctc wfe tenlo gmzsh brewb lczt elc cjwtciuwd ex wqc gzsh, zlo z
melp elc lczt wqc ewqct. Wqc bszmcb fctc cjsccoulpmd qzto zlo pmebbd, fuwq zmm wqc
zrrcztzlsc ex gntlubqco pemo. Wqc fcupqw ex wqc ulbcsw fzb actd tcizthzgmc, zlo,
wzhulp zmm wqulpb ulwe selbuoctzwuel, U senmo qztomd gmzic Ynruwct xet qub eruluel
tcbrcswulp uw.

Wqc xmzp ub: ruseSWX{5NG5717N710L_3A0MN710L_357GX9XX}
```

Using a substitution cipher decoder tool like [this one](https://planetcalc.com/8047/) , 
we can easily decode the message and obtain the flag:

![HashCrack Screenshot](/assets/lib/pic9.png)

## Flag:
```
PICOCTF{5UB5717U710N_3V0LU710N_357BF9FF}
```

# Substitution1


![HashCrack Screenshot](/assets/lib/pic7.png)

### Hints:
```
Try a frequency attack
Do the punctuation and the individual words help you make any substitutions?
```

This is the msg given:
``` 
ZWDg (gejfw djf zacwpfx wex dqar) afx a wscx jd zjicpwxf gxzpfbws zjicxwbwbjv. Zjvwxgwavwg afx cfxgxvwxm hbwe a gxw jd zeaqqxvrxg hebze wxgw wexbf zfxawbybws, wxzevbzaq (avm rjjrqbvr) gnbqqg, avm cfjtqxi-gjqybvr atbqbws. Zeaqqxvrxg pgpaqqs zjyxf a vpitxf jd zawxrjfbxg, avm hexv gjqyxm, xaze sbxqmg a gwfbvr (zaqqxm a dqar) hebze bg gptibwwxm wj av jvqbvx gzjfbvr gxfybzx. ZWDg afx a rfxaw has wj qxafv a hbmx affas jd zjicpwxf gxzpfbws gnbqqg bv a gadx, qxraq xvybfjvixvw, avm afx ejgwxm avm cqasxm ts iavs gxzpfbws rfjpcg afjpvm wex hjfqm djf dpv avm cfazwbzx. Djf webg cfjtqxi, wex dqar bg: cbzjZWD{DF3LP3VZS_4774ZN5_4F3_Z001_4871X6DT}
```
Use CyberChef to manually break the substitution cipher.

Flag:
```
PICOCTF{FR3QU3NCY_4774CK5_4R3_C001_7AA384BC}
```

# Pixelated

## Description
I have these 2 images, can you make a flag out of them?
scrambled1.png scrambled2.png

## Hints
https://en.wikipedia.org/wiki/Visual_cryptography
Think of different ways you can “stack” images

## Solution
We can use the concept of visual cryptography to solve this problem.
```
Visual Cryptography is a cryptographic technique where an image is divided into multiple shares (or layers) so that individually, they reveal no information. However, when these shares are overlaid or stacked together, the original image or secret can be visually reconstructed without needing a computer—just the human eye
```

so basically, we need to combine two photos that were given to us in order to retrieve the original image.
I wrote a Python code using chatGPT for this purpose:
```
from PIL import Image

def combine_images(image1_path, image2_path, output_path):
    # Open the images
    image1 = Image.open(image1_path)
    image2 = Image.open(image2_path)

    # Ensure both images have the same size
    if image1.size != image2.size:
        raise ValueError("Images must have the same size")

    # Combine the images using a simple averaging technique
    combined_image = Image.blend(image1, image2, alpha=0.5)

    # Save the combined image
    combined_image.save(output_path)

if __name__ == "__main__":
    # Provide the paths of the input images and the desired output path
    image1_path = "scrambled1.png"
    image2_path = "scrambled2.png"
    output_path = "combined_image.png"

    combine_images(image1_path, image2_path, output_path)
```

  this is what i got after running the code:


  ![HashCrack Screenshot](/assets/lib/combined_image.png)

  After Zooming it in a website  https://29a.ch/photo-forensics/#forensic-magnifier

  I can see the flag is:
```
  picoCTF{1b867c3e}
```

# john_pollard

## Description
Sometimes RSA certificates are breakable

## Hints:
The flag is in the format picoCTF{p,q}
Try swapping p and q if it does not work

## Solution

they had given a cetificate 
we need to find p and q from the certificate
so i decoded it using https://8gwifi.org/PemParserFunctions.jsp

Find the modulus value in the decoded certificate.
```
Modulus:966306421059967 
```
To solve this challenge, we need to find the prime factors of the RSA modulus `n`. 
We can use [Alpertron](https://www.alpertron.com.ar/ECM.HTM) to find the prime factors of `n`.
 ![HashCrack Screenshot](/assets/lib/cert.png)

## Flag:
```
picoCTF{73176001,67867967}
```

# waves over lambda
## Description
We made alot of substitutions to encrypt this. Can you decrypt it? Connect with nc 2019shell1.picoctf.com 32282.

## Hints:
Flag is not in the usual flag format

## Solution:
![HashCrack Screenshot](/assets/encrypt.png)

Run the above encrypted one in https://www.quipqiup.com/ to get the following:

![HashCrack Screenshot](/assets/lib/flag.png)

So here is the Flag as per hint:
```
frequency_is_c_over_lambda_
```

# Rotation
## Description:
You will find the flag after decrypting this file
Download the encrypted flag here.
https://artifacts.picoctf.net/c/386/encrypted.txt

## Hints:

Sometimes rotation is right

#### File contains:
```
xqkwKBN{z0bib1wv_l3kzgxb3l_4k71n5j0}
```
## Solution:
We can use this tool [Caesar Cipher Decoder](https://www.dcode.fr/caesar-cipher) to decrypt the file: 

![HashCrack Screenshot](/assets/lib/pic10.png)

## Flag:
```
picoCTF{r0tat1on_d3crypt3d_4c71f5b0}
```

# ReadMyCert
## Description:
How about we take you on an adventure on exploring certificate signing requests
Take a look at this CSR file here.
https://artifacts.picoctf.net/c/424/readmycert.csr

## Hints:
Download the certificate signing request and try to read it.

# HideToSee

![HashCrack Screenshot](/assets/lib/pic11.png)

## Hints:
Download the image and try to extract it.

## Solution:
Download the image. It looks like this:

![HashCrack Screenshot](/assets/lib/atbash.jpg)

After opening the file, we now know that the flag is likely encrypted using the Atbash Cipher. 

However, since we are tasked to extract hidden files, I tried using Stegseek

![HashCrack Screenshot](/assets/lib/pic12.png)

So Extracted Data is:
```
krxlXGU{zgyzhs_xizxp_7142uwv9}
```
![HashCrack Screenshot](/assets/lib/pic13.png)

 We can simply use an online Atbash Cipher tool to decrypt the flag. I used this.
## Flag:
```
picoCTF{atbash_crack_7142fde9}
```

# basic-mod1

## Description:
We found this weird message being passed around on the servers, we think we have a working decryption scheme.
Download the message here.
Take each number mod 37 and map it to the following character set: 0-25 is the alphabet (uppercase), 26-35 are the decimal digits, and 36 is an underscore.
Wrap your decrypted message in the picoCTF flag format (i.e. picoCTF{decrypted_message})

## Hints:
Do you know what mod 37 means?
mod 37 means modulo 37. It gives the remainder of a number after being divided by 37.

## Solution:
Encrypted message is: 
```
128 322 353 235 336 73 198 332 202 285 57 87 262 221 218 405 335 101 256 227 112 140 
```
Lets write a simple python program which reads the message into a string first.

Then I will read each number into an array and take each number in the array mod 37

After that I will try to map each array field to the following scheme:

0-25 is the alphabet (uppercase), 26-35 are the decimal digits, and 36 is an underscore.


```

import string

# read the file into a string

with open('message.txt', 'r') as file:

    enc_msg = file.read()

# split the string by ' ' and insert the values into an array

enc_arr = enc_msg.split( )

# print out the array for test purposes

enc_arr_len = len(enc_arr)

# define empty mod_arr

mod_arr = []

# calculate modulo 37 of every number

for i in range(0, enc_arr_len):

        mod_arr.append(round(int(enc_arr[i]) % 37))

# get length of resulting array

mod_arr_len = len(mod_arr)

# define array for final string

final_string = []

for i in range(0, mod_arr_len):

        # try to map numbers from 0 to 25 to uppercase characters of the alphabet
        if 0 <= int(mod_arr[i]) <= 25:

                if(int(mod_arr[i]) == 0):

                        final_string.append('A')

                elif(int(mod_arr[i]) == 1):

                        final_string.append('B')

                elif(int(mod_arr[i]) == 2):

                        final_string.append('C')

                elif(int(mod_arr[i]) == 3):

                        final_string.append('D')

                elif(int(mod_arr[i]) == 4):

                        final_string.append('E')

                elif(int(mod_arr[i]) == 5):

                        final_string.append('F')

                elif(int(mod_arr[i]) == 6):

                        final_string.append('G')

                elif(int(mod_arr[i]) == 7):

                        final_string.append('H')

                elif(int(mod_arr[i]) == 8):

                        final_string.append('I')

                elif(int(mod_arr[i]) == 9):

                        final_string.append('J')

                elif(int(mod_arr[i]) == 10):

                        final_string.append('K')

                elif(int(mod_arr[i]) == 11):

                        final_string.append('L')

                elif(int(mod_arr[i]) == 12):

                        final_string.append('M')

                elif(int(mod_arr[i]) == 13):

                        final_string.append('N')

                elif(int(mod_arr[i]) == 14):

                        final_string.append('O')

                elif(int(mod_arr[i]) == 15):

                        final_string.append('P')

                elif(int(mod_arr[i]) == 16):

                        final_string.append('Q')

                elif(int(mod_arr[i]) == 17):

                        final_string.append('R')

                elif(int(mod_arr[i]) == 18):

                        final_string.append('S')

                elif(int(mod_arr[i]) == 19):

                        final_string.append('T')

                elif(int(mod_arr[i]) == 20):

                        final_string.append('U')

                elif(int(mod_arr[i]) == 21):

                        final_string.append('V')

                elif(int(mod_arr[i]) == 22):

                        final_string.append('W')

                elif(int(mod_arr[i]) == 23):

                        final_string.append('X')

                elif(int(mod_arr[i]) == 24):

                        final_string.append('Y')

                elif(int(mod_arr[i]) == 25):

                        final_string.append('Z')

        # try to map numbers from 26 to 35 to decimal digits

        elif 26 <= int(mod_arr[i]) <= 35:

                if(int(mod_arr[i]) == 26):

                        final_string.append('0')

                elif(int(mod_arr[i]) == 27):

                        final_string.append('1')

                elif(int(mod_arr[i]) == 28):

                        final_string.append('2')

                elif(int(mod_arr[i]) == 29):

                        final_string.append('3')

                elif(int(mod_arr[i]) == 30):

                        final_string.append('4')

                elif(int(mod_arr[i]) == 31):

                        final_string.append('5')

                elif(int(mod_arr[i]) == 32):

                        final_string.append('6')

                elif(int(mod_arr[i]) == 33):

                        final_string.append('7')

                elif(int(mod_arr[i]) == 34):

                        final_string.append('8')

                elif(int(mod_arr[i]) == 35):

                        final_string.append('9')

        # try to map 36 to an underscore _

        elif int(mod_arr[i]) == 36:

                final_string.append("_")
final_flag = ''.join(final_string)
print("picoCTF{" + final_flag + "}")
```
# Flag:
```
picoCTF{R0UND_N_R0UND_B0D5F596}
```
# basic-mod2

## Description:
A new modular challenge!
Download the message here.
Take each number mod 41 and find the modular inverse for the result. Then map to the following character set: 1-26 are the alphabet, 27-36 are the decimal digits, and 37 is an underscore.
Wrap your decrypted message in the picoCTF flag format (i.e. picoCTF{decrypted_message})

## Hints:
Do you know what the modular inverse is?
The inverse modulo z of x is the number, y that when multiplied by x is 1 modulo z
It's recommended to use a tool to find the modular inverses


This challenge is similar to the previous challenge, basic-mod1,
but instead of calculating the modulus of each number, we need to calculate the modular inverse. There is also a slight difference in the character set instructions that we need to consider.

## Solution:
downloaded file displays a string of numbers:
```
 268 413 438 313 426 337 272 188 392 338 77 332 139 113 92 239 247 120 419 72 295 190 131
```
We need to calculate the modular inverse of each number and  map it to a character in the predefined character set in the description. I used a python script to do this.

```
chrs = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
enc_message = "268 413 438 313 426 337 272 188 392 338 77 332 139 113 92 239 247 120 419 72 295 190 131"
flag = ""
 
def modular_inverse(x: int, m: int) -> int:
   return pow(x, -1, m)
 
for i in enc_message.split():
   mod_inverse = modular_inverse(int(i),41)
 
   # -1 since the character set for this challenge starts from 1, unlike the previous challenge
   flag += chrs[mod_inverse-1]
 
print(flag)

## Flag:
```
picoCTF{1NV3R53LY_H4RD_8A05D939}

# Credstuff

![HashCrack Screenshot](/assets/lib/pic14.png)

[leak](https://artifacts.picoctf.net/c/534/leak.tar)


### Hints:
Maybe other passwords will have hints about the leak?

### Solution:
let’s write a python program that finds the corresponding password for the user ‘cultiris’

According to the task description the n-th user corresponds to the n-th password.

So my task here is to find the position of the user ‘cultiris’ in the file ‘usernames.txt’ and find the password with the same position in the file ‘passwords.txt’

Here is the program I came up with:
```
username="cultiris"

username_file="leak/usernames.txt"

password_file="leak/passwords.txt"

def search_string_in_file(file_name, string_to_search):

    """Search for the given string in file and return lines containing that string,

    along with line numbers"""

    line_number = 0

    list_of_results = []  # Open the file in read only mode

    with open(file_name, 'r') as read_obj:
        for line in read_obj:

            # For each line, check if line contains the string

            line_number += 1

            if string_to_search in line:

                # If yes, then add the line number & line as a tuple in the list

                list_of_results.append((line_number, line.rstrip()))

    # Return list of tuples containing line numbers and lines where string is found

    return list_of_results



print(search_string_in_file(username_file, username))
lines = []                             		
with open ('leak/passwords.txt', 'rt') as psswd_file: 

    for line in psswd_file:               
        lines.append(line)   

print(lines[377])
```
Using my python program I found the username ‘cultiris’ on line 378:

So all I have to do now is to extract line 378 of the file ‘passwords.txt’.
I got this:
```
cvpbPGS{P7e1S_54I35_71Z3}
```
This seems to be encrypted.

I will Use a online tool [ROT13] to decrypt this.

### Flag:
```
picoCTF{C7r1F_54V35_71M3}
```
